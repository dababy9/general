package si413.spl;

import si413.spl.ast.Statement;
import java.util.List;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import org.jline.terminal.Terminal;
import org.jline.terminal.TerminalBuilder;
import org.jline.utils.AttributedStyle;
import org.jline.utils.AttributedStringBuilder;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.BufferedTokenStream;
import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.impl.Arguments;
import net.sourceforge.argparse4j.inf.ArgumentParser;
import net.sourceforge.argparse4j.inf.ArgumentParserException;
import net.sourceforge.argparse4j.inf.Namespace;

/** Front-end main method for the SPL compiler.
 * This handles scanning, parsing, and command-line arguments,
 * creates a global frame and fresh contents, and then
 * turns things over to the AST compile methods.
 *
 * You should not need to make any changes to this class.
 */
public class Compiler implements Runnable {
    /** Whether or not to print info messages to stderr explaining what the compiler is doing. */
    private boolean verbose;
    /** The SPL source code stream. */
    private CharStream source = null;
    /** The LLVM IR output code stream. */
    private PrintWriter dest = null;
    /** The JLine terminal to use for colorized output. */
    private Terminal terminal = null;

    /** Takes the given AST (list of statement nodes) and generates LLVM IR code.
     * This is the only method of the class you might need to modify.
     */
    public void generateCode(List<Statement> program) {
        // header
        dest.println("; Generated by SPL Compiler");
        dest.println();
        dest.println("target triple = \"x86_64-pc-linux-gnu\"");
        dest.println();

        // function prototypes
        dest.println("declare i32 @printf(ptr, ...)");
        dest.println();
        dest.println("declare i32 @scanf(ptr)");
        dest.println();

        // global constants
        dest.println("@printLong = constant [4 x i8] c\"%d\\0A\\00\"");
        dest.println();
        dest.println("@scanLong = constant [2 x i8] c\"%d\"");
        dest.println();

        Frame global = Frame.makeGlobal();
        // main
        dest.println("define i32 @main() {");
        Context ctx = new Context(dest);
        for (Statement stmt : program) {
            stmt.compile(global, ctx);
        }
        dest.println("  ret i32 0");
        dest.println("}");

        dest.close();
    }

    /** If enabled, prints a message to stderr explaining what the compiler is doing. */
    public void info(String message) {
        if (verbose) {
            if (terminal == null) System.err.println(message);
            else {
                terminal.writer().println(new AttributedStringBuilder()
                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.BLUE))
                    .append(message)
                    .style(AttributedStyle.DEFAULT)
                    .toAnsi());
                terminal.flush();
            }
        }
    }

    /** Prints an compilation error message and terminates the compiler. */
    public void error(String message) {
        String emsg = "ERROR: " + message;
        if (terminal == null) System.err.format(emsg);
        else {
            terminal.writer().println(new AttributedStringBuilder()
                .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))
                .append(emsg)
                .style(AttributedStyle.DEFAULT)
                .toAnsi());
            terminal.flush();
        }
        System.exit(5);
    }

    /** Runs the compiler through all stages. */
    @Override
    public void run() {
        info("Scanning and Parsing...");
        ErrorCatcher err = new ErrorCatcher();
        SPLLexer lexer = new SPLLexer(source);
        err.attach(lexer);
        TokenStream tokens = new BufferedTokenStream(lexer);
        SPLParser parser = new SPLParser(tokens);
        err.attach(parser);
        SPLParser.ProgContext parseTree = null;
        try { parseTree = parser.prog(); }
        catch (SPLError e) { error(e.getMessage()); }

        info("Semantic analysis...");
        StlistBuilder astBuilder = new StlistBuilder();
        List<Statement> program = astBuilder.visit(parseTree);

        info("Code generation...");
        try { generateCode(program); }
        catch (SPLError e) { error(e.getMessage()); }

        info("Compilation complete");
    }

    /** Initializes the compiler based on command-line options. */
    public Compiler(String sourceFile, String destFile, boolean toStdout, boolean verbose)
        throws IOException
    {
        assert destFile == null || ! toStdout;

        this.verbose = verbose;
        if (System.console() == null) terminal = null;
        else {
            try { terminal = TerminalBuilder.builder().build(); }
            catch (IOException e) { terminal = null; }
        }

        info("SPL compiler started");

        if (sourceFile == null || sourceFile.equals("-")) {
            // read from stdin
            info("Reading from standard in. Enter your SPL commands followed by EOF (Ctrl-D).");
            source = CharStreams.fromStream(System.in);
            if (destFile == null) toStdout = true;
        } else {
            // try to read from named file
            source = CharStreams.fromFileName(sourceFile);
            info("Reading from '%s'".formatted(sourceFile));
        }

        if (toStdout || "-".equals(destFile)) {
            dest = new PrintWriter(System.out, true);
        }
        else {
            Path destPath;
            if (destFile == null) {
                Path srcPath = Path.of(sourceFile);
                String destName = srcPath.getFileName().toString();
                if (destName.endsWith(".spl"))
                    destName = destName.substring(0, destName.lastIndexOf(".spl")) + ".ll";
                else destName += ".ll";
                destPath = srcPath.resolveSibling(destName);
            }
            else destPath = Path.of(destFile);
            dest = new PrintWriter(new FileWriter(destPath.toFile()), true);
            info("Writing to '%s'".formatted(destPath));
        }
    }

    /** Main method to process command-line arguments, instantiate and run a Compiler. */
    public static void main(String[] args) throws IOException {
        ArgumentParser parser = ArgumentParsers.newFor("SPL Compiler")
            .build()
            .defaultHelp(true);
        parser.addArgument("-s", "--stdout")
            .action(Arguments.storeTrue())
            .help("Print resulting LLVM IR code to stdout instead of writing to a file");
        parser.addArgument("-q", "--quiet")
            .action(Arguments.storeTrue())
            .help("Don't print messages to stderr saying what the compier is doing");
        parser.addArgument("sourceFile")
            .nargs("?")
            .help("Source file of SPL code to run (- or blank means read from stdin)");
        parser.addArgument("outputFile")
            .nargs("?")
            .help("Output .ll file (default comes from source filename");
        Namespace ns = null;
        try { ns = parser.parseArgs(args); }
        catch (ArgumentParserException e) {
            parser.handleError(e);
            System.exit(1);
        }

        boolean verbose = ! Boolean.TRUE.equals(ns.getBoolean("quiet"));
        boolean toStdout = Boolean.TRUE.equals(ns.getBoolean("stdout"));
        String sourceFile = ns.getString("sourceFile");
        String destFile = ns.getString("outputFile");

        if (toStdout && destFile != null) {
            parser.handleError(new ArgumentParserException(
                "Cannot specify both --stdout and outputFile",
                parser));
            System.exit(1);
        }

        new Compiler(sourceFile, destFile, toStdout, verbose).run();
    }
}
